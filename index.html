<!DOCTYPE html>
<html>
    <head>
            <meta charset=utf-8>
            <title>My first three.js app</title>
            <style>
                body { margin: 0; }
                canvas { width: 100%; height: 100% }
            </style>
    </head>
    <script src="js/three.js"></script>
    <script>

        const createCube = (scene) => {
            const cube = {};

            const geometry = new THREE.BoxGeometry( 1, 1, 1 );
            const material = new THREE.MeshPhongMaterial( { color: 0xff6464 } );
            const cubeMesh = new THREE.Mesh( geometry, material );

            scene.add(cubeMesh);

            cube.update = (delta) => {
                cubeMesh.rotation.x += delta * 0.6;
                cubeMesh.rotation.y += delta * 0.8;                
            };

            return cube;
        };

        const randomBetween = (min, max) => {
            return Math.random() * (max - min) + min;
        };

        const randomVec2 = (min, max) => {
            return {
                x: randomBetween(min, max),
                y: randomBetween(min, max)
            };
        };

        const randomDirection = () => {
            const factor = 2 * Math.PI * Math.random();

            return {
                u: Math.cos(factor),
                v: Math.sin(factor)
            };
        };

        const createWorld = () => {
            const boids = {};
            const world = {
                
            };

            world.addBoid = (position, direction, speed, key) => {
                boids[key] = {position, direction, speed};
            };

            world.update = (delta) => {
                for (const key in boids) {
                    const velocity = boids[key].direction.clone();
                    velocity.multiplyScalar(boids[key].speed);
                    velocity.multiplyScalar(delta);
                    boids[key].position.add(velocity);
                };
            };

            world.getPositionOf = (key) => {
                return boids[key].position;
            };

            return world;
        };

        const createBoidMesh = (scene, boidGeometry, boidMaterial, startPos) => {
            const boid = {};

            const geometry = boidGeometry || new THREE.BoxGeometry(1, 1, 1);
            const material = boidMaterial || new THREE.MeshPhongMaterial({ color: 0xff6464 });
            const boidMesh = new THREE.Mesh(geometry, material);

            scene.add(boidMesh);

            boid.mesh = boidMesh;

            return boid;
        };

        const update = (delta, graph, world) => {
            world.update(delta);
            for (const node of graph) {
                const {x, y, z} = world.getPositionOf(node.tag);
                node.mesh.position.set(x, y, z);
            }
        };

        const createFloor = () => {
            var floorGeometry = new THREE.PlaneGeometry(10, 10, 5, 5);
            var floorMaterial = new THREE.MeshPhongMaterial( { color: 0x6464ff } );
            var floor = new THREE.Mesh( floorGeometry, floorMaterial );

            floor.position.set(0, -1.5, 0);
            floor.rotation.x = -90 * (Math.PI / 180);
            return floor;
        };

        const createLights = () => {
            var pointLights = [];
            pointLights[0] = new THREE.PointLight(0xffffff, 1, 0);
            pointLights[0].position.set(100, 10, 0);

            pointLights[1] = new THREE.PointLight(0xffffff, 1, 0);
            pointLights[1].position.set(0, 10, 0);
            
            pointLights[2] = new THREE.PointLight(0xffffff, 1, 0);
            pointLights[2].position.set(0, 0, 5);

            return pointLights;
        };

        const createCamera = () => {
            var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10);
            var camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 0.1, 10);
            camera.zoom = 70;
            camera.updateProjectionMatrix();
            camera.position.y = 6;
            camera.position.z = 0;
            camera.up = new THREE.Vector3(0, 1, 0);
            camera.lookAt(new THREE.Vector3(0, 0, 0))
            return camera;
        };

        const setup = (scene) => {
            const world = createWorld();
            const graph = [];

            const boidGeometry = new THREE.BoxGeometry( 0.1, 0.1, 0.1 );
            const boidMaterial = new THREE.MeshPhongMaterial( { color: 0xff6464 } );

            for (let i = 0; i < 100; i++) {
                const boid = createBoidMesh(scene, boidGeometry, boidMaterial);   
                boid.tag = i;             
                graph.push(boid);    
                const {x, y} = randomVec2(-5, 5);
                const location = new THREE.Vector3(x, 0, y);
                const {u, v} = randomDirection();
                const direction = new THREE.Vector3(u, 0, v);
                var speed = 0.75;
                world.addBoid(location, direction, speed, boid.tag);
            }

            
            scene.add(createFloor());

            var pointLights = createLights();
            
            for (const light of pointLights) {
                scene.add(light);
            }

            var camera = createCamera();

            return {world, graph, camera};
        };

        const createRenderLoop = (clock, graph, scene, camera, renderer, world) => {
            const internalRender = () => {
                window.requestAnimationFrame(internalRender);

                var delta = clock.getDelta();
                update(delta, graph, world);

                renderer.render(scene, camera);
            }
            return internalRender;
        };

        window.onload = () => {
            var scene = new THREE.Scene();

            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            var {world, graph, camera} = setup(scene);

            var clock = new THREE.Clock();

            var render = createRenderLoop(clock, graph, scene, camera, renderer, world);

            render();
        };
    </script>
</html>