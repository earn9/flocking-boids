<!DOCTYPE html>
<html>
    <head>
            <meta charset=utf-8>
            <title>My first three.js app</title>
            <style>
                body { margin: 0; }
                canvas { width: 100%; height: 100% }
            </style>
    </head>
    <script src="js/three.js"></script>
    <script>

        const createCube = (scene) => {
            const cube = {};

            const geometry = new THREE.BoxGeometry( 1, 1, 1 );
            const material = new THREE.MeshPhongMaterial( { color: 0xff6464 } );
            const cubeMesh = new THREE.Mesh( geometry, material );

            scene.add(cubeMesh);

            cube.update = (delta) => {
                cubeMesh.rotation.x += delta * 0.6;
                cubeMesh.rotation.y += delta * 0.8;                
            };

            return cube;
        };

        const randomBetween = (min, max) => {
            return Math.random() * (max - min) + min;
        };

        const randomVec2 = (min, max) => {
            return {
                x: randomBetween(min, max),
                y: randomBetween(min, max)
            };
        };

        const randomDirection = () => {
            const factor = 2 * Math.PI * Math.random();

            return {
                u: Math.cos(factor),
                v: Math.sin(factor)
            };
        };

        const createBoid = (scene, boidGeometry, boidMaterial, startPos) => {
            const boid = {};

            const geometry = boidGeometry || new THREE.BoxGeometry(1, 1, 1);
            const material = boidMaterial || new THREE.MeshPhongMaterial({ color: 0xff6464 });
            const boidMesh = new THREE.Mesh(geometry, material);
            boidMesh.position.set(startPos.x, 0, startPos.y);

            scene.add(boidMesh);

            const {u, v} = randomDirection();
            const direction = new THREE.Vector3(u, 0, v);
            var speed = 0.75;

            boid.update = (delta) => {
                const velocity = direction.clone();
                velocity.multiplyScalar(speed);
                velocity.multiplyScalar(delta);
                boidMesh.position.add(velocity);
            };

            return boid;
        };

        const update = (delta, graph) => {
            for (const node of graph) {
                node.update(delta);
            }
        };

        const createFloor = () => {
            var floorGeometry = new THREE.PlaneGeometry(10, 10, 5, 5);
            var floorMaterial = new THREE.MeshPhongMaterial( { color: 0x6464ff } );
            var floor = new THREE.Mesh( floorGeometry, floorMaterial );

            floor.position.set(0, -1.5, 0);
            floor.rotation.x = -90 * (Math.PI / 180);
            return floor;
        };

        const createLights = () => {
            var pointLights = [];
            pointLights[0] = new THREE.PointLight(0xffffff, 1, 0);
            pointLights[0].position.set(100, 10, 0);

            pointLights[1] = new THREE.PointLight(0xffffff, 1, 0);
            pointLights[1].position.set(0, 10, 0);
            
            pointLights[2] = new THREE.PointLight(0xffffff, 1, 0);
            pointLights[2].position.set(0, 0, 5);

            return pointLights;
        };

        const createCamera = () => {
            var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10);
            var camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 0.1, 10);
            camera.zoom = 70;
            camera.updateProjectionMatrix();
            camera.position.y = 6;
            camera.position.z = 0;
            camera.up = new THREE.Vector3(0, 1, 0);
            camera.lookAt(new THREE.Vector3(0, 0, 0))
            return camera;
        };

        const setup = (scene) => {
            const graph = [];

            const boidGeometry = new THREE.BoxGeometry( 0.1, 0.1, 0.1 );
            const boidMaterial = new THREE.MeshPhongMaterial( { color: 0xff6464 } );

            for (let i = 0; i < 100; i++) {
                graph.push(createBoid(scene, boidGeometry, boidMaterial, randomVec2(-5, 5)));    
            }

            scene.add(createFloor());

            var pointLights = createLights();
            
            for (const light of pointLights) {
                scene.add(light);
            }

            var camera = createCamera();

            return {graph, camera};
        };

        const createRenderLoop = (clock, graph, scene, camera, renderer) => {
            const internalRender = () => {
                window.requestAnimationFrame(internalRender);

                var delta = clock.getDelta();
                update(delta, graph);

                renderer.render(scene, camera);
            }
            return internalRender;
        };

        window.onload = () => {
            var scene = new THREE.Scene();

            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            var {graph, camera} = setup(scene);

            var clock = new THREE.Clock();

            var render = createRenderLoop(clock, graph, scene, camera, renderer);

            render();
        };
    </script>
</html>