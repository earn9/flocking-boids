<!DOCTYPE html>
<html>
    <head>
            <meta charset=utf-8>
            <title>My first three.js app</title>
            <style>
                body { margin: 0; }
                canvas { width: 100%; height: 100% }
            </style>
    </head>
    <script src="js/three.js"></script>
    <script>

        const createCube = (scene) => {
            const cube = {};

            const geometry = new THREE.BoxGeometry( 1, 1, 1 );
            const material = new THREE.MeshPhongMaterial( { color: 0xff6464 } );
            const cubeMesh = new THREE.Mesh( geometry, material );

            scene.add(cubeMesh);

            cube.update = (delta) => {
                cubeMesh.rotation.x += delta * 0.6;
                cubeMesh.rotation.y += delta * 0.8;                
            };

            return cube;
        };

        const randomBetween = (min, max) => {
            return Math.random() * (max - min) + min;
        };

        const randomVec2 = (min, max) => {
            return {
                x: randomBetween(min, max),
                y: randomBetween(min, max)
            }
        };

        const createBoid = (scene, boidGeometry, boidMaterial, startPos) => {
            const boid = {};

            const geometry = boidGeometry || new THREE.BoxGeometry(1, 1, 1);
            const material = boidMaterial || new THREE.MeshPhongMaterial({ color: 0xff6464 });
            const boidMesh = new THREE.Mesh(geometry, material);
            boidMesh.position.set(startPos.x, 0, startPos.y);

            scene.add(boidMesh);

            const direction = new THREE.Vector3(1, 0, 0);
            var speed = 0.75;

            boid.update = (delta) => {
                const velocity = direction.clone();
                velocity.multiplyScalar(speed);
                velocity.multiplyScalar(delta);
                boidMesh.position.add(velocity);
            };

            return boid;
        };

        const update = (delta, graph) => {
            for (const node of graph) {
                node.update(delta);
            }
        };

        const setup = (scene) => {
            const graph = [];

            const boidGeometry = new THREE.BoxGeometry( 0.1, 0.1, 0.1 );
            const boidMaterial = new THREE.MeshPhongMaterial( { color: 0xff6464 } );

            graph.push(createBoid(scene, boidGeometry, boidMaterial, randomVec2(-10, 10)));
            graph.push(createBoid(scene, boidGeometry, boidMaterial, randomVec2(-10, 10)));
            graph.push(createBoid(scene, boidGeometry, boidMaterial, randomVec2(-10, 10)));
            graph.push(createBoid(scene, boidGeometry, boidMaterial, randomVec2(-10, 10)));
            graph.push(createBoid(scene, boidGeometry, boidMaterial, randomVec2(-10, 10)));
            graph.push(createBoid(scene, boidGeometry, boidMaterial, randomVec2(-10, 10)));
            graph.push(createBoid(scene, boidGeometry, boidMaterial, randomVec2(-10, 10)));
            graph.push(createBoid(scene, boidGeometry, boidMaterial, randomVec2(-10, 10)));

            var floorGeometry = new THREE.PlaneGeometry(10, 10, 5, 5);
            var floorMaterial = new THREE.MeshPhongMaterial( { color: 0x6464ff } );
            var floor = new THREE.Mesh( floorGeometry, floorMaterial );

            floor.position.set(0, -1.5, 0);
            floor.rotation.x = -90 * (Math.PI / 180);
            scene.add(floor);

            var pointLights = [];
            pointLights[0] = new THREE.PointLight(0xffffff, 1, 0);
            pointLights[0].position.set(100, 10, 0);

            pointLights[1] = new THREE.PointLight(0xffffff, 1, 0);
            pointLights[1].position.set(0, 10, 0);
            
            pointLights[2] = new THREE.PointLight(0xffffff, 1, 0);
            pointLights[2].position.set(0, 0, 5);
            
            scene.add(pointLights[0]);
            scene.add(pointLights[1]);
            scene.add(pointLights[2]);

            return graph;
        };

        const createRenderLoop = (clock, graph, scene, camera, renderer) => {
            const internalRender = () => {
                window.requestAnimationFrame(internalRender);

                var delta = clock.getDelta();
                update(delta, graph);

                renderer.render(scene, camera);
            }
            return internalRender;
        };

        window.onload = () => {
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            var graph = setup(scene);

            camera.position.z = 5;

            var clock = new THREE.Clock();

            var render = createRenderLoop(clock, graph, scene, camera, renderer);

            render();
        };
    </script>
</html>